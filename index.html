<!DOCTYPE html>
<html>

<head>
  <title>RPCG</title> <!-- Changed title to RPCG -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" as="style">
  <style>
    /* Import Google Font Inter */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

    /* CSS variables for pastel colors and dark theme */
    :root {
      --background-dark: #0a0a0a;
      --hud-background-dark: #1f1f1f;
      --main-border-color: #AECAD2; /* Pastel blue for main border, used consistently */
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: var(--background-dark);
      color: white;
      font-family: 'Inter', sans-serif;
      margin: 0;
      touch-action: none; /* Disable default touch actions like scrolling */
      overflow: hidden; /* Hide overflow to prevent scrollbars */
      width: 100vw; /* Occupy full viewport width */
      height: 100vh; /* Occupy full viewport height */
      justify-content: center;
      position: relative;
    }

    /* Main game canvas now covers the entire screen */
    canvas { 
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      z-index: 1; /* Lowest Z-index, as it's the primary drawing surface */
      background-color: transparent; /* Background drawn by canvas itself */
    }

    #hud {
      display: flex;
      gap: 15px;
      margin-top: 10px; /* Small margin from top */
      flex-wrap: wrap;
      justify-content: center;
      z-index: 5; /* HUD above canvas and menu */
      position: absolute; /* Position above canvas */
      top: 20px; /* Position from top */
      width: 100%; /* Take full width to center items */
    }

    .hud-item {
      font-size: 18px;
      background: rgba(31, 31, 31, 0.9); /* Add transparency */
      padding: 8px 15px;
      border-radius: 8px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5); /* Better contrast */
      backdrop-filter: blur(5px); /* Frosted glass effect */
      -webkit-backdrop-filter: blur(5px); /* For Safari */
      border: 2px solid rgba(255, 255, 255, 0.15); /* Slightly thinner border for better aesthetics with transparency */
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
      transition: all 0.2s ease-out;
    }

    /* Class for HUD pulse animation */
    .hud-item.animate-pulse {
      animation: hudPulseFlat 0.3s ease-out forwards;
    }

    @keyframes hudPulseFlat {
      0%, 100% { 
          transform: scale(1);
          background-color: var(--hud-background-dark); 
          color: white;
      }
      50% { 
          transform: scale(1.05); /* Slightly increased scale for more noticeable pulse */
          background-color: #FFECB3; 
          color: black;
      }
    }

    /* Menu Styles (Start and Settings, and Pause) */
    .game-menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 4;
      background-color: rgba(31, 31, 31, 0.95); /* Consistent with settings-group */
      border-radius: 12px; /* Consistent with settings-group */
      border: 2px solid rgba(255, 255, 255, 0.1); /* Consistent with settings-group */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Consistent with settings-group */
      text-align: center;
      transition: opacity 0.3s ease;
    }

    .game-menu.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .game-menu h1 {
      font-size: clamp(2em, 8vw, 4em);
      color: white;
      margin-bottom: clamp(10px, 4vw, 30px);
      text-shadow: none;
    }

    .menu-option-button {
      padding: clamp(8px, 3vw, 16px) clamp(16px, 6vw, 32px); /* Optimized with clamp() */
      font-size: clamp(14px, 4vw, 18px); /* Optimized with clamp() */
      background-color: #C3F8B7;
      color: #1a1a1a;
      border: 6px solid var(--main-border-color); /* Increased border size and consistent color */
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      text-shadow: none;
      margin: 8px 0;
      width: clamp(200px, 60vw, 300px);
      max-width: 90%;
    }

    .menu-option-button:hover {
      background-color: #AECAD2;
      color: white;
      border-color: #FFD1DC;
      transform: scale(1.05);
    }

    .info-text {
      text-align: center;
      padding: 10px;
      color: #aaa;
      font-size: clamp(0.8em, 2vw, 1.1em);
      text-shadow: none;
      z-index: 5;
      position: absolute;
      bottom: 20px;
      width: 100%;
    }

    /* Styles for settings options */
    .settings-group {
        margin-bottom: 25px;
        color: #ddd;
        background-color: rgba(31, 31, 31, 0.7); /* Semi-transparent background */
        padding: 20px;
        border-radius: 12px;
        border: 2px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        width: clamp(280px, 80vw, 500px); /* Responsive width */
        max-width: 90%;
        box-sizing: border-box; /* Include padding in width */
    }
    .settings-group h2 {
        font-size: clamp(1.2em, 5vw, 2.2em);
        margin-bottom: 15px;
        color: white;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    .settings-options {
        display: flex;
        flex-wrap: wrap; /* Allow buttons to wrap to next line */
        justify-content: center;
        gap: 10px; /* Space between buttons */
    }
    .settings-options button {
        background-color: var(--hud-background-dark);
        color: white;
        border: 4px solid rgba(255, 255, 255, 0.1); /* Increased border size */
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        margin: 0; /* Reset margin from parent */
        transition: all 0.2s ease;
        flex-grow: 1; /* Allow buttons to grow and fill space */
        min-width: 100px; /* Minimum width for buttons */
        max-width: 150px; /* Max width for buttons */
    }
    .settings-options button:hover {
        background-color: #555;
    }
    .settings-options button.active {
        background-color: #C3F8B7; /* Active pastel green */
        color: #1a1a1a;
        border-color: var(--main-border-color); /* Consistent border color */
        box-shadow: 0 0 8px var(--main-border-color); /* Glow for active button */
    }

    /* Adjustments for Settings Menu to allow scrolling */
    #settingsMenu {
      display: flex;
      flex-direction: column;
      justify-content: flex-start; /* Align content to the top */
      padding-top: 5vh; /* Add some padding at the top */
      padding-bottom: 5vh; /* Add some padding at the bottom */
      overflow-y: auto; /* Enable vertical scrolling */
      max-height: 90vh; /* Restrict height to enable scrolling if content overflows */
      box-sizing: border-box; /* Include padding in the height calculation */
      align-items: center; /* Center groups horizontally */
      gap: 20px; /* Space between setting groups */
    }

    /* Modal styles for custom alert */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 100; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
        justify-content: center;
        align-items: center;
    }

    .modal-content {
        background-color: #1f1f1f;
        margin: auto;
        padding: 30px;
        border: 5px solid var(--main-border-color);
        border-radius: 15px;
        width: 80%;
        max-width: 400px;
        text-align: center;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .modal-content h2 {
        color: white;
        font-size: 1.8em;
    }

    .modal-content p {
        color: #ddd;
        font-size: 1.1em;
        white-space: pre-wrap; /* Preserve new lines from alert content */
    }

    .modal-content button {
        background-color: #C3F8B7;
        color: #1a1a1a;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1.1em;
        font-weight: bold;
        transition: background-color 0.2s ease;
    }

    .modal-content button:hover {
        background-color: #AECAD2;
        color: white;
    }

    /* New styles for score screen */
    #scoreScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 4;
        background-color: rgba(31, 31, 31, 0.95); /* Consistent with settings-group */
        border-radius: 12px; /* Consistent with settings-group */
        border: 2px solid rgba(255, 255, 255, 0.1); /* Consistent with settings-group */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Consistent with settings-group */
        text-align: center;
        transition: opacity 0.3s ease;
    }

    #scoreScreen.hidden {
        opacity: 0;
        pointer-events: none;
    }

    #scoreScreen h1 {
        font-size: clamp(2em, 8vw, 4em);
        color: white;
        margin-bottom: clamp(10px, 4vw, 30px);
    }

    #scoreScreen p {
        font-size: clamp(1.2em, 5vw, 2em);
        color: #ddd;
        margin-bottom: 15px;
    }

    #scoreScreen .menu-option-button {
        margin-top: 20px;
    }

    /* Styles for intro animation text */
    #introAnimationText {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: clamp(2em, 10vw, 5em);
        color: white;
        text-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
        opacity: 0;
        z-index: 6; /* Above menus */
        pointer-events: none;
    }

    /* Class to trigger intro animation */
    #introAnimationText.animate-intro {
        animation: fadeInOut 2s ease-out forwards;
    }

    @keyframes fadeInOut {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
    }

    /* Orientation warning message */
    #orientationWarning {
        display: none; /* Hidden by default */
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.95);
        color: white;
        font-size: clamp(1em, 5vw, 2em);
        text-align: center;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        flex-direction: column;
        padding: 20px;
    }

    @media screen and (orientation: landscape) and (max-height: 500px) { /* Adjust breakpoint as needed */
        #orientationWarning {
            display: flex;
        }
    }
    @media screen and (orientation: portrait) and (max-width: 500px) { /* Adjust breakpoint as needed */
        #orientationWarning {
            display: none; /* Hide for portrait on small screens */
        }
    }

  </style>
</head>

<body>
  <div id="startMenu" class="game-menu">
    <h1>RPCG</h1> <!-- Changed title to RPCG -->
    <button id="playButton" class="menu-option-button">Jugar</button>
    <button id="settingsButton" class="menu-option-button">Configuración</button>
    <button id="aboutButton" class="menu-option-button">Acerca de</button>
    <p style="color: #ccc; margin-top: 20px;">Presiona SPACE para jugar</p>
  </div>

  <div id="settingsMenu" class="game-menu hidden">
    <h1>Configuración</h1>

    <div class="settings-group">
        <h2>Renderizado</h2>
        <div class="settings-options">
            <button id="renderer2d" class="active">Canvas 2D</button>
            <button id="rendererWebGL">WebGL</button>
        </div>
    </div>

    <div class="settings-group">
        <h2>Gráficos</h2>
        <div class="settings-options">
            <button id="graphicsLow">Baja</button>
            <button id="graphicsMedium" class="active">Media</button>
            <button id="graphicsHigh">Alta</button>
        </div>
    </div>

    <div class="settings-group">
        <h2>Dificultad</h2>
        <div class="settings-options">
            <button id="difficultyEasy">Fácil</button>
            <button id="difficultyNormal" class="active">Normal</button>
            <button id="difficultyHard">Difícil</button>
        </div>
    </div>

    <div class="settings-group">
        <h2>Shaders</h2>
        <div class="settings-options">
            <button id="shaderOff" class="active">Off</button>
            <button id="shaderInvert">Inversión de Color</button>
            <button id="shaderChromaticGlow">Aberración Cromática y Brillo</button>
        </div>
    </div>

    <div class="settings-group">
        <h2>Modo de Color</h2> <!-- New Color Mode setting -->
        <div class="settings-options">
            <button id="colorModePerRound">Por Ronda</button>
            <button id="colorModeRainbow" class="active">Arcoíris</button>
            <button id="colorModeMonochromatic">Monocromático</button> <!-- New Monochromatic button -->
        </div>
    </div>

    <div class="settings-group">
        <h2>Anti-Aliasing (Canvas 2D)</h2>
        <div class="settings-options">
            <button id="imageSmoothingSmooth" class="active">Suave</button>
            <button id="imageSmoothingPixelated">Píxel</button>
        </div>
    </div>

    <div class="settings-group">
        <h2>Anti-Aliasing (WebGL)</h2>
        <div class="settings-options">
            <button id="antiAliasingNone" class="active">Ninguno</button>
            <button id="antiAliasingMSAAx2">MSAA x2</button>
            <button id="antiAliasingFXAA">FXAA</button>
        </div>
    </div>

    <button id="backToMainMenuButton" class="menu-option-button">Volver</button>
  </div>

  <!-- New Pause Menu -->
  <div id="pauseMenu" class="game-menu hidden">
    <h1>Juego Pausado</h1>
    <button id="continueButton" class="menu-option-button">Continuar</button>
    <button id="restartButton" class="menu-option-button">Reiniciar</button>
    <button id="exitToMenuButton" class="menu-option-button">Salir al Menú Principal</button>
  </div>

  <!-- New Score Screen -->
  <div id="scoreScreen" class="game-menu hidden">
    <h1>Resultados Finales</h1>
    <p>Puntuación: <span id="finalScore">0</span></p>
    <p>Precisión: <span id="finalAccuracy">0%</span></p>
    <p>Clasificación: <span id="finalRank">E</span></p>
    <button id="playAgainButton" class="menu-option-button">Jugar de Nuevo</button>
  </div>

  <div id="hud">
    <div class="hud-item">Puntuación: <span id="score">0</span></div>
    <div class="hud-item">BPM: <span id="bpm">0</span></div>
    <div class="hud-item">Precisión: <span id="accuracy">100%</span></div>
    <div class="hud-item">Combo: <span id="combo">0</span></div>
  </div>
  <canvas id="gameCanvas"></canvas> <!-- Main game canvas, now full screen -->
  <div class="info-text" id="gameInfoText"> <!-- Added ID for easier manipulation -->
    Presiona SPACE o toca cuando los círculos coincidan
  </div>

  <!-- Intro Animation Text -->
  <div id="introAnimationText" class="hidden">¡Prepárate!</div>

  <!-- Custom Modal for Alerts -->
  <div id="customAlertModal" class="modal">
      <div class="modal-content">
          <h2 id="customAlertTitle"></h2>
          <p id="customAlertMessage"></p>
          <button id="customAlertCloseButton">OK</button>
      </div>
  </div>

  <!-- Orientation Warning -->
  <div id="orientationWarning">
      <p>Para una mejor experiencia de juego, por favor, rota tu dispositivo a orientación vertical.</p>
      <p>(O asegúrate de que tu pantalla no sea demasiado ancha en modo horizontal)</p>
  </div>

  <script>
    // --- Constants and Configuration ---
    // Game precision base settings (thresholds are in degrees).
    // Values have been reduced for stricter precision.
    const BASE_PRECISION = {
      NANO: { threshold: 1.0, score: 350, color: '#AECAD2', text: 'NANO!' },
      PERFECT: { threshold: 2.5, score: 300, color: '#C3F8B7', text: 'PERFECT!' },
      BEST: { threshold: 5, score: 150, color: '#FFFACD', text: 'BEST!' },
      GOOD: { threshold: 8, score: 75, color: '#FFD1DC', text: 'GOOD' },
      BAD: { threshold: 12, score: 25, color: '#D5B8FF', text: 'BAD' },
      MISS: { threshold: Infinity, score: 0, color: '#FF7F7F', text: 'MISS' }
    };

    // Difficulty multipliers for precision thresholds
    const DIFFICULTY_MULTIPLIERS = {
        'easy': 1.5,   // Wider threshold, easier to hit
        'normal': 1.0, // Base threshold
        'hard': 0.7    // Narrower threshold, harder to hit
    };

    // Graphics settings: (num_background_squares, particles_count, num_background_lines)
    const GRAPHICS_SETTINGS = {
        'low': { squares: 20, particles: 10, lines: 10 },
        'medium': { squares: 70, particles: 35, lines: 35 },
        'high': { squares: 150, particles: 100, lines: 60 }
    };

    const TRAIL_LENGTH = 20;
    const HIT_TEXT_LIFETIME = 900;
    const TRIANGLE_COUNT_MAIN_CIRCLE = 16;
    const TRIANGLE_SIZE_MAIN = 0.05;

    const COMBO_TEXT_LIFETIME = 1500; // Duration for "COMBO X!" text
    const ROUND_COMPLETE_TEXT_LIFETIME = 2000; // 2 seconds for "ROUND X COMPLETED!" text
    const INTRO_ANIMATION_DURATION = 2000; // 2 seconds for intro animation

    // Pastel color palette
    const PASTEL_COLORS = [
      '#FFD1DC', // Pastel Pink
      '#BCE2E8', // Pastel Blue
      '#FFFACD', // Pastel Yellow
      '#C3F8B7', // Pastel Green
      '#D5B8FF', // Pastel Lavender
      '#FFECB3'  // Pastel Peach
    ];
    let currentColorIndex = 0;
    let colorUpdateIntervalId; // To store the interval ID for color updates

    // Global variables for background elements and particles count,
    // which will be updated by graphics settings
    let NUM_BACKGROUND_SQUARES = GRAPHICS_SETTINGS.medium.squares;
    let PARTICLES_COUNT = GRAPHICS_SETTINGS.medium.particles;
    let NUM_BACKGROUND_LINES = GRAPHICS_SETTINGS.medium.lines;

    // --- Optimization Constants ---
    const MAX_PARTICLES = 200; // Max number of particles at any given time
    const MAX_FEEDBACK_TEXTS = 20; // Max number of hit/combo/round texts at any given time
    const DEG_TO_RAD = Math.PI / 180; // Precalculated constant for degree to radian conversion

    // --- Object Pools ---
    const particlePool = Array(MAX_PARTICLES).fill(null).map(() => ({})); // Initialize with empty objects
    let nextAvailableParticleIndex = 0;

    const hitTextPool = Array(MAX_FEEDBACK_TEXTS).fill(null).map(() => ({}));
    let nextAvailableHitTextIndex = 0;

    const comboTextPool = Array(MAX_FEEDBACK_TEXTS).fill(null).map(() => ({}));
    let nextAvailableComboTextIndex = 0;

    const roundCompleteTextPool = Array(MAX_FEEDBACK_TEXTS).fill(null).map(() => ({}));
    let nextAvailableRoundCompleteTextIndex = 0;

    // --- DOM Elements ---
    const canvas = document.getElementById('gameCanvas'); // Main game canvas
    let ctx = null; // To be initialized based on renderer
    let gl = null; // To be initialized later
    
    const elements = {
      score: document.getElementById('score'),
      bpm: document.getElementById('bpm'),
      accuracy: document.getElementById('accuracy'),
      combo: document.getElementById('combo'), // New combo element
      startMenu: document.getElementById('startMenu'),
      playButton: document.getElementById('playButton'),
      settingsButton: document.getElementById('settingsButton'),
      aboutButton: document.getElementById('aboutButton'),
      settingsMenu: document.getElementById('settingsMenu'),
      backToMainMenuButton: document.getElementById('backToMainMenuButton'),
      renderer2d: document.getElementById('renderer2d'),
      rendererWebGL: document.getElementById('rendererWebGL'),
      graphicsLow: document.getElementById('graphicsLow'),
      graphicsMedium: document.getElementById('graphicsMedium'),
      graphicsHigh: document.getElementById('graphicsHigh'),
      difficultyEasy: document.getElementById('difficultyEasy'),
      difficultyNormal: document.getElementById('difficultyNormal'),
      difficultyHard: document.getElementById('difficultyHard'),
      shaderOff: document.getElementById('shaderOff'), // New shader button
      shaderInvert: document.getElementById('shaderInvert'), // New shader button for inversion
      shaderChromaticGlow: document.getElementById('shaderChromaticGlow'), // New shader button for chromatic + glow
      customAlertModal: document.getElementById('customAlertModal'),
      customAlertTitle: document.getElementById('customAlertTitle'),
      customAlertMessage: document.getElementById('customAlertMessage'),
      customAlertCloseButton: document.getElementById('customAlertCloseButton'),
      pauseMenu: document.getElementById('pauseMenu'), // New pause menu element
      continueButton: document.getElementById('continueButton'), // New continue button
      restartButton: document.getElementById('restartButton'), // New restart button
      exitToMenuButton: document.getElementById('exitToMenuButton'), // New exit button
      colorModePerRound: document.getElementById('colorModePerRound'), // New color mode button
      colorModeRainbow: document.getElementById('colorModeRainbow'),   // New color mode button
      colorModeMonochromatic: document.getElementById('colorModeMonochromatic'), // New monochromatic button
      gameInfoText: document.getElementById('gameInfoText'), // Reference to the info text
      scoreScreen: document.getElementById('scoreScreen'), // New score screen element
      finalScore: document.getElementById('finalScore'), // Final score display
      finalAccuracy: document.getElementById('finalAccuracy'), // Final accuracy display
      finalRank: document.getElementById('finalRank'), // Final rank display
      playAgainButton: document.getElementById('playAgainButton'), // Play again button
      introAnimationText: document.getElementById('introAnimationText'), // Intro animation text
      orientationWarning: document.getElementById('orientationWarning'), // Orientation warning
      imageSmoothingSmooth: document.getElementById('imageSmoothingSmooth'), // New 2D AA button
      imageSmoothingPixelated: document.getElementById('imageSmoothingPixelated'), // New 2D AA button
      antiAliasingNone: document.getElementById('antiAliasingNone'), // New WebGL AA button
      antiAliasingMSAAx2: document.getElementById('antiAliasingMSAAx2'), // New WebGL AA button
      antiAliasingFXAA: document.getElementById('antiAliasingFXAA'), // New WebGL AA button
    };

    // --- Game State ---
    let gameState = {
      phase: 'menu', // 'menu', 'introAnimation', 'playing', 'ended', 'settings', 'roundComplete', 'paused', 'scoreScreen'
      score: 0,
      lastTime: 0,
      currentRoundIndex: 0,
      totalHits: 0,
      totalAttempts: 0,
      activeMarkers: [],
      particles: [], // Active particles
      hitFeedbackTexts: [], // Active hit feedback texts
      comboFeedbackTexts: [], // Active combo texts
      roundCompleteTexts: [], // Active round complete texts
      player: {
        angle: 0,
        radius: 0,
        trail: []
      },
      startTime: 0,
      globalTime: 0,
      currentRenderer: '2d', // '2d' or 'webgl'
      currentDifficulty: 'normal', // Default difficulty
      currentGraphicsQuality: 'medium', // Default graphics quality
      activeShader: 'none', // 'none', 'invert', 'chromatic_glow'
      combo: 0, // Current combo count
      centralReelPulseScale: 1, // For central reel animation
      nextRoundStartTime: 0, // Time when next round should start
      colorMode: 'rainbow', // Default color mode
      introAnimationStartTime: 0, // For intro animation
      finalScoreValue: 0, // Store final score for score screen
      finalAccuracyValue: 0, // Store final accuracy for score screen
      imageSmoothingEnabled: true, // Default for 2D anti-aliasing
      currentAntiAliasing: 'none', // 'none', 'msaa_x2', 'fxaa' for WebGL
    };

    // --- WebGL Data ---
    let webglData = {
        program: null,
        positionAttributeLocation: null,
        resolutionUniformLocation: null,
        colorUniformLocation: null,
        positionBuffer: null,

        // MSAA related
        msaaFramebuffer: null,
        msaaRenderbuffer: null,
        msaaTexture: null, // For blitting to a texture if needed for post-processing chain

        // FXAA related
        fxaaProgram: null,
        fxaaPositionLocation: null,
        fxaaTexCoordLocation: null,
        fxaaResolutionUniform: null,
        fxaaSamplerUniform: null,
        quadBuffer: null,
        sceneTextureFramebuffer: null,
        sceneTexture: null,
    };

    // Main game circle object (for size and position reference)
    const mainCircle = { x: 0, y: 0, radius: 0 };

    // Arrays to store background elements properties
    let backgroundSquares = [];
    let backgroundLines = []; // New array for background lines

    // Game rounds with different BPM and note patterns
    const rounds = [
      { bpm: 60, notes: [90, 270], beatsPerRotation: 2 },
      { bpm: 90, notes: [0, 120, 240], beatsPerRotation: 3 },
      { bpm: 120, notes: [45, 135, 225, 315], beatsPerRotation: 4 },
      { bpm: 150, notes: [0, 72, 144, 216, 288], beatsPerRotation: 5 }
    ];

    // Off-screen canvas for shader effects
    let tempCanvas = null;
    let tempCtx = null;

    // Variable to track if spacebar is currently pressed to prevent multiple hits on keydown auto-repeat
    let isSpacePressed = false;

    // Debounce variable for gameplay input (keyboard and touch)
    let lastGameplayInputTime = 0;
    const GAMEPLAY_INPUT_COOLDOWN = 20; // 20ms cooldown to prevent multiple rapid taps

    // --- Utility Functions ---
    /**
     * Muestra un modal de alerta personalizado con un título y un mensaje.
     * @param {string} title - El título de la alerta.
     * @param {string} message - El contenido del mensaje de la alerta.
     */
    function customAlert(title, message) {
        elements.customAlertTitle.textContent = title;
        elements.customAlertMessage.textContent = message;
        elements.customAlertModal.style.display = 'flex';
    }

    /** Oculta el modal de alerta personalizado. */
    function hideCustomAlert() {
        elements.customAlertModal.style.display = 'none';
    }

    /**
     * Convierte una cadena de color hexadecimal en un array de valores RGB normalizados [r, g, b].
     * @param {string} hex - La cadena de color hexadecimal (ej. "#RRGGBB").
     * @returns {Array<number>} Un array que contiene los valores RGB de 0 a 1.
     */
    function hexToRgbNormalized(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        return [r, g, b];
    }

    /**
     * Convierte una cadena de color hexadecimal en una cadena RGB (ej. "255,0,255").
     * @param {string} hex - La cadena de color hexadecimal (ej. "#RRGGBB").
     * @returns {string} La cadena RGB.
     */
    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `${r},${g},${b}`;
    }

    /**
     * Recupera el valor de una variable CSS y lo convierte en una cadena RGB para dibujar en el canvas.
     * @param {string} cssVar - El nombre de la variable CSS (ej. '--main-border-color').
     * @returns {string} La cadena RGB (ej. "174,202,210").
     */
    function var_to_rgb(cssVar) {
        const computedStyle = getComputedStyle(document.body);
        const color = computedStyle.getPropertyValue(cssVar).trim();
        if (color.startsWith('#')) {
            return hexToRgb(color);
        }
        // Si ya está en formato rgb() o rgba(), extrae solo los valores RGB
        if (color.startsWith('rgb(') || color.startsWith('rgba(')) {
            return color.match(/\d+/g).slice(0,3).join(',');
        }
        return '255,255,255'; // Por defecto, blanco si no se reconoce
    }

    /** Actualiza el índice de color actual para ciclar a través de los colores pastel. */
    function updatePsychedelicColors() {
      // Esta función solo será llamada por setInterval si colorMode es 'rainbow'
      currentColorIndex = (currentColorIndex + 1) % PASTEL_COLORS.length;
    }

    /** Inicializa (o reinicializa) los cuadrados y líneas de fondo. */
    function initializeBackgroundElements() {
        backgroundSquares = [];
        backgroundLines = [];

        // Los elementos de fondo deben cubrir todo el viewport
        const bgAreaWidth = window.innerWidth;
        const bgAreaHeight = window.innerHeight;

        // Inicializa los cuadrados de fondo
        for (let i = 0; i < NUM_BACKGROUND_SQUARES; i++) {
            backgroundSquares.push({
                x: Math.random() * bgAreaWidth,
                y: Math.random() * bgAreaHeight,
                size: Math.random() * 50 + 20,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.00005, // Rotación más lenta
                moveSpeedX: (Math.random() - 0.5) * 0.005, // Movimiento más lento para paralaje
                moveSpeedY: (Math.random() - 0.5) * 0.005,
                color: PASTEL_COLORS[Math.floor(Math.random() * PASTEL_COLORS.length)],
                alpha: Math.random() * 0.1 + 0.03 // Opacidad muy baja para el fondo
            });
        }

        // Inicializa las líneas de fondo
        for (let i = 0; i < NUM_BACKGROUND_LINES; i++) {
            backgroundLines.push({
                x: Math.random() * bgAreaWidth,
                y: Math.random() * bgAreaHeight,
                length: Math.random() * 100 + 50,
                angle: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.0001, // Rotación ligeramente más rápida que los cuadrados
                moveSpeed: Math.random() * 0.08 + 0.03, // Movimiento más rápido que los cuadrados para más paralaje
                color: PASTEL_COLORS[Math.floor(Math.random() * PASTEL_COLORS.length)],
                alpha: Math.random() * 0.08 + 0.02 // Opacidad muy baja
            });
        }
    }

    // --- Initialization Functions ---
    /** Ajusta el tamaño del canvas de forma responsiva e inicializa los elementos de fondo. */
    const setCanvasSize = () => {
      const dpr = window.devicePixelRatio || 1;

      // Establece las dimensiones para el canvas principal del juego para cubrir toda la ventana
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = `${window.innerWidth}px`;
      canvas.style.height = `${window.innerHeight}px`;
      
      if (gameState.currentRenderer === '2d' && ctx) {
        ctx.scale(dpr, dpr); // Escala el contexto para pantallas de alta DPI
      } else if (gl) {
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      }

      // Inicializa o redimensiona el canvas fuera de pantalla para los shaders
      if (gameState.currentRenderer === '2d' && !tempCanvas) {
        tempCanvas = document.createElement('canvas');
        tempCtx = tempCanvas.getContext('2d');
      }
      if (tempCanvas) {
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
      }

      // mainCircle.x y mainCircle.y están centrados en relación con el canvas completo
      mainCircle.x = window.innerWidth / 2;
      mainCircle.y = window.innerHeight / 2;
      
      // mainCircle.radius escala con la dimensión mínima de la ventana
      const gameAreaSize = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      mainCircle.radius = gameAreaSize * 0.45; // Órbita más grande
      gameState.player.radius = mainCircle.radius * 0.08; // Tamaño del jugador en relación con la órbita

      initializeBackgroundElements(); // Reinicializa los elementos de fondo para el canvas completo
    };
    
    // --- Game Logic Functions ---
    function startRound(roundIndex) {
      if (roundIndex >= rounds.length) {
          // Si todas las rondas están completas, ve a la pantalla de puntuación
          showScoreScreen();
          return;
      }

      const round = rounds[roundIndex];
      // Reinicia solo el estado de golpeo para los nuevos marcadores de ronda
      gameState.activeMarkers = round.notes.map(angle => ({ angle, hit: false, originalAngle: angle }));
      elements.bpm.textContent = round.bpm;
      gameState.player.angle = 0;
      gameState.player.trail = [];
      gameState.currentRoundIndex = roundIndex;

      // Si el modo de color es "Por Ronda", establece el color una vez para la ronda
      if (gameState.colorMode === 'per_round') {
          currentColorIndex = Math.floor(Math.random() * PASTEL_COLORS.length); // Elige un color aleatorio para la ronda
      } else if (gameState.colorMode === 'monochromatic') {
          // Monochromatic mode: set a fixed grey/white color
          currentColorIndex = 0; // Or any other index that maps to a grey/white if you add them to PASTEL_COLORS
          // For now, let's just use a fixed grey for monochromatic
          // We'll override the color selection logic in draw functions for monochromatic
      }
    }

    function endGame() {
        // Esta función ahora es principalmente para establecer la fase en 'ended'
        // La visualización real de la puntuación/rango se maneja mediante showScoreScreen()
        gameState.phase = 'ended'; 
        gameState.comboFeedbackTexts = []; // Limpia cualquier texto de combo flotante
        gameState.roundCompleteTexts = []; // Limpia cualquier texto de ronda completa
        updateHUD(); // Asegura que el HUD refleje el estado final
        // No hay dibujo directo en el canvas aquí, se llamará a showScoreScreen
    }

    /**
     * Calcula el rango de precisión basado en un porcentaje.
     * @param {number} accuracyPercentage - La precisión como porcentaje (ej. 95.5).
     * @returns {string} El rango (ej. "SX", "A").
     */
    function getAccuracyRank(accuracyPercentage) {
        if (accuracyPercentage === 100) return 'SX';
        if (accuracyPercentage >= 95) return 'S';
        if (accuracyPercentage >= 90) return 'A';
        if (accuracyPercentage >= 80) return 'B';
        if (accuracyPercentage >= 70) return 'C';
        return 'E';
    }

    /** Muestra la pantalla de puntuación final. */
    function showScoreScreen() {
        gameState.phase = 'scoreScreen';
        elements.finalScore.textContent = gameState.score;
        const accuracy = gameState.totalAttempts === 0 ? 100 : (gameState.totalHits / gameState.totalAttempts * 100);
        gameState.finalAccuracyValue = accuracy.toFixed(1); // Almacena para mostrar
        elements.finalAccuracy.textContent = `${gameState.finalAccuracyValue}%`;
        elements.finalRank.textContent = getAccuracyRank(parseFloat(gameState.finalAccuracyValue));
        elements.scoreScreen.classList.remove('hidden');
    }

    function resetGameStats() {
        gameState.score = 0;
        gameState.totalHits = 0;
        gameState.totalAttempts = 0;
        gameState.combo = 0; // Combo reiniciado aquí (al inicio de un nuevo juego)
        // Limpia los textos de retroalimentación activos y reinicia los pools
        gameState.comboFeedbackTexts = [];
        gameState.roundCompleteTexts = [];
        gameState.hitFeedbackTexts = [];
        gameState.particles = [];
        nextAvailableParticleIndex = 0;
        nextAvailableHitTextIndex = 0;
        nextAvailableComboTextIndex = 0;
        nextAvailableRoundCompleteTextIndex = 0;
        updateHUD();
    }


    function checkHit() {
      const currentAngle = (gameState.player.angle % 360 + 360) % 360; // Calcula el ángulo actual una vez
      gameState.totalAttempts++;
      let bestPrecision = BASE_PRECISION.MISS;
      let hitMarkerIndex = -1;

      let closestDiff = Infinity;
      gameState.activeMarkers.forEach((marker, index) => {
        if (!marker.hit) {
          const angleDiff = Math.min(
            Math.abs(currentAngle - marker.angle),
            Math.abs(currentAngle - (marker.angle + 360)),
            Math.abs(currentAngle - (marker.angle - 360))
          );
          if (angleDiff < closestDiff) {
            closestDiff = angleDiff;
            hitMarkerIndex = index;
          }
        }
      });

      if (hitMarkerIndex !== -1) {
        const marker = gameState.activeMarkers[hitMarkerIndex];
        bestPrecision = calculatePrecision(closestDiff);

        if (bestPrecision.score > 0) {
          gameState.score += bestPrecision.score;
          gameState.totalHits++;
          marker.hit = true;
          createParticles(marker.originalAngle, bestPrecision.color, true);
          createHitFeedbackText(bestPrecision.text, bestPrecision.color);

          // Lógica del sistema de combo: Incrementa el combo en un golpe exitoso
          gameState.combo++;
          if (gameState.combo > 1 && gameState.combo % 5 === 0) { // Muestra el texto del combo cada 5 golpes
              createComboFeedbackText(`COMBO ${gameState.combo}!`, PASTEL_COLORS[currentColorIndex]);
          }
          gameState.centralReelPulseScale = 1.1; // Inicia la animación de pulso del carrete central
        } else {
            // Si es un golpe MALO o FALLO, reinicia el combo
            gameState.combo = 0;
            createHitFeedbackText(bestPrecision.text, BASE_PRECISION.MISS.color); // Always use MISS color for broken combo feedback
            createComboFeedbackText('COMBO BROKEN!', '#FF7F7F'); // Texto rojo para combo roto
        }
      } else {
          // Si no se golpeó ningún marcador (entrada perdida, pero ningún marcador activo estaba lo suficientemente cerca), reinicia el combo
          gameState.combo = 0;
          createHitFeedbackText(BASE_PRECISION.MISS.text, BASE_PRECISION.MISS.color);
          createComboFeedbackText('COMBO BROKEN!', '#FF7F7F'); // Texto rojo para combo roto
      }

      updateHUD();

      const allMarkersHit = gameState.activeMarkers.every(marker => marker.hit);
      if (allMarkersHit) {
        createRoundCompleteText(`RONDA ${gameState.currentRoundIndex + 1} COMPLETADA!`, PASTEL_COLORS[currentColorIndex]);
        gameState.phase = 'roundComplete';
        gameState.nextRoundStartTime = gameState.globalTime + 2000; // 2 segundos de retraso
      }
    }

    /**
     * Calcula la precisión en función de la diferencia de ángulo y la configuración de dificultad actual.
     * @param {number} angleDiff - La diferencia absoluta en el ángulo entre el jugador y el marcador.
     * @returns {object} El nivel de precisión (NANO, PERFECTO, etc.).
     */
    function calculatePrecision(angleDiff) {
        const difficultyMultiplier = DIFFICULTY_MULTIPLIERS[gameState.currentDifficulty];
        
        for (const key in BASE_PRECISION) {
            const precisionLevel = BASE_PRECISION[key];
            // Aplica el multiplicador solo a los umbrales que no son Infinito (es decir, no FALLO)
            if (precisionLevel.threshold !== Infinity && angleDiff <= precisionLevel.threshold * difficultyMultiplier) {
                return precisionLevel;
            }
        }
        return BASE_PRECISION.MISS;
    }

    /**
     * Obtiene el color actual para el renderizado, basado en el modo de color.
     * @param {string} defaultColor - El color pastel predeterminado si no es monocromático.
     * @returns {string} El color hexadecimal a usar.
     */
    function getCurrentRenderColor(defaultColor) {
        if (gameState.colorMode === 'monochromatic') {
            return '#CCCCCC'; // A light grey for monochromatic elements
        }
        return defaultColor;
    }

    /**
     * Crea partículas visuales en un ángulo y color dados, reutilizando de un pool.
     * @param {number} angle - El ángulo en el círculo donde deben aparecer las partículas.
     * @param {string} color - El color de las partículas (cadena hexadecimal).
     * @param {boolean} isSquare - Verdadero si las partículas deben ser cuadradas, falso para circulares.
     */
    function createParticles(angle, color, isSquare = false) {
      if (gameState.currentRenderer === 'webgl') {
          // TODO: Implementar partículas WebGL
          return;
      }
      const radian = angle * DEG_TO_RAD;
      const spawnRadius = mainCircle.radius;
      const x = mainCircle.x + Math.cos(radian) * spawnRadius;
      const y = mainCircle.y + Math.sin(radian) * spawnRadius;

      for (let i = 0; i < PARTICLES_COUNT; i++) {
        // Obtiene una partícula del pool
        const particle = particlePool[nextAvailableParticleIndex];
        nextAvailableParticleIndex = (nextAvailableParticleIndex + 1) % MAX_PARTICLES;

        const speed = Math.random() * 3 + 0.5;
        const angleOffset = (Math.random() - 0.5) * Math.PI / 2;
        const particleAngle = radian + angleOffset;
        
        // Reinicia y establece las propiedades para la partícula reciclada
        particle.x = x;
        particle.y = y;
        particle.vx = Math.cos(particleAngle) * speed;
        particle.vy = Math.sin(particleAngle) * speed;
        particle.alpha = 1;
        particle.size = Math.random() * 4 + 2;
        particle.color = getCurrentRenderColor(color); // Apply color mode here
        particle.isSquare = isSquare;

        gameState.particles.push(particle); // Agrega a las partículas activas
      }
    }

    /**
     * Crea un texto flotante de retroalimentación (ej. "¡PERFECTO!"), reutilizando de un pool.
     * @param {string} text - El texto a mostrar.
     * @param {string} color - El color del texto (cadena hexadecimal).
     */
    function createHitFeedbackText(text, color) {
        if (gameState.currentRenderer === 'webgl') {
            // TODO: Implementar renderizado de texto WebGL
            return;
        }
        const textObj = hitTextPool[nextAvailableHitTextIndex];
        nextAvailableHitTextIndex = (nextAvailableHitTextIndex + 1) % MAX_FEEDBACK_TEXTS;

        textObj.text = text;
        textObj.x = mainCircle.x;
        textObj.y = mainCircle.y - mainCircle.radius * 0.5;
        textObj.alpha = 1;
        textObj.color = getCurrentRenderColor(color); // Apply color mode here
        textObj.startTime = gameState.globalTime;
        
        gameState.hitFeedbackTexts.push(textObj);
    }

    /**
     * Crea un texto flotante de combo (ej. "¡COMBO X!"), reutilizando de un pool.
     * @param {string} text - El texto a mostrar.
     * @param {string} color - El color del texto (cadena hexadecimal).
     */
    function createComboFeedbackText(text, color) {
        if (gameState.currentRenderer === 'webgl') return;
        const textObj = comboTextPool[nextAvailableComboTextIndex];
        nextAvailableComboTextIndex = (nextAvailableComboTextIndex + 1) % MAX_FEEDBACK_TEXTS;

        textObj.text = text;
        textObj.x = mainCircle.x;
        textObj.y = mainCircle.y + mainCircle.radius * 0.5;
        textObj.alpha = 1;
        textObj.color = getCurrentRenderColor(color); // Apply color mode here
        textObj.startTime = gameState.globalTime;

        gameState.comboFeedbackTexts.push(textObj);
    }

    /**
     * Crea un texto flotante de ronda completada (ej. "¡RONDA X COMPLETADA!"), reutilizando de un pool.
     * @param {string} text - El texto a mostrar.
     * @param {string} color - El color del texto (cadena hexadecimal).
     */
    function createRoundCompleteText(text, color) {
        if (gameState.currentRenderer === 'webgl') return;
        const textObj = roundCompleteTextPool[nextAvailableRoundCompleteTextIndex];
        nextAvailableRoundCompleteTextIndex = (nextAvailableRoundCompleteTextIndex + 1) % MAX_FEEDBACK_TEXTS;

        textObj.text = text;
        textObj.x = mainCircle.x;
        textObj.y = mainCircle.y + mainCircle.radius * 0.0;
        textObj.alpha = 1;
        textObj.color = getCurrentRenderColor(color); // Apply color mode here
        textObj.startTime = gameState.globalTime;

        gameState.roundCompleteTexts.push(textObj);
    }

    /** Actualiza la visualización del HUD (puntuación, BPM, precisión, combo). */
    function updateHUD() {
      elements.score.textContent = gameState.score;
      const accuracy = gameState.totalAttempts === 0 ? 100 : (gameState.totalHits / gameState.totalAttempts * 100).toFixed(1);
      elements.accuracy.textContent = `${accuracy}%`;
      elements.combo.textContent = gameState.combo;
    }

    /** Dibuja el único carrete central (centro de cassette minimalista) con un efecto de pulso. */
    function drawCentralReel() {
        // Change: Inner lines color from white to a variable for flexibility,
        // but keeping it white for now as per "cambio de color al circulo exterior a blanco"
        const innerLineColor = '#FFFFFF'; 

        let reelRadius = mainCircle.radius * 0.7; 
        
        // Aplica el efecto de pulso para el carrete central
        if (gameState.centralReelPulseScale > 1) {
            reelRadius *= gameState.centralReelPulseScale;
            // Disminuye la escala del pulso de vuelta a 1 con el tiempo
            gameState.centralReelPulseScale -= (gameState.centralReelPulseScale - 1) * 0.3; // Decaimiento más rápido
            if (gameState.centralReelPulseScale < 1.005) gameState.centralReelPulseScale = 1; // Ajusta a 1
        }

        ctx.save();
        ctx.translate(mainCircle.x, mainCircle.y);
        ctx.rotate(gameState.globalTime * 0.001); // Gira lentamente el carrete central

        // Gradiente radial para un sutil efecto de brillo en el centro
        const gradientRadius = reelRadius * 0.8;
        const glowColor = getCurrentRenderColor(PASTEL_COLORS[currentColorIndex]);
        const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gradientRadius);
        glowGradient.addColorStop(0, `rgba(${hexToRgb(glowColor)}, 0.3)`); // Brillo interior
        glowGradient.addColorStop(0.5, `rgba(${hexToRgb(glowColor)}, 0.1)`);
        glowGradient.addColorStop(1, 'rgba(0,0,0,0)'); // Transparente exterior

        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(0, 0, gradientRadius, 0, Math.PI * 2);
        ctx.fill();

        // Círculo exterior del carrete (solo borde, sin relleno)
        ctx.beginPath();
        ctx.arc(0, 0, reelRadius, 0, Math.PI * 2);
        ctx.strokeStyle = '#FFFFFF'; // Borde blanco para el carrete
        ctx.lineWidth = 6; // Grosor del borde aumentado para el carrete (de 4 a 6)
        ctx.stroke();

        // Radios interiores (simulando dientes de carrete)
        const numSpokes = 8;
        for (let i = 0; i < numSpokes; i++) {
            const spokeAngle = (Math.PI * 2 / numSpokes) * i;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(spokeAngle) * reelRadius, Math.sin(spokeAngle) * reelRadius);
            ctx.strokeStyle = innerLineColor;
            ctx.lineWidth = 3; // Grosor de línea aumentado para los radios (de 2 a 3)
            ctx.stroke();
        }

        ctx.restore();
    }

    /** Dibuja pequeños triángulos en el borde interior del círculo principal. */
    function drawInnerBorderTriangles() {
        const numTriangles = TRIANGLE_COUNT_MAIN_CIRCLE;
        const angleStep = (Math.PI * 2) / numTriangles;
        const triangleBase = mainCircle.radius * (TRIANGLE_SIZE_MAIN + 0.01); // Base ligeramente más grande
        const triangleHeight = triangleBase * Math.sqrt(3) / 2;

        for (let i = 0; i < numTriangles; i++) {
            const angle = i * angleStep;
            // El centro del triángulo es relativo al radio de órbita del jugador
            const cx = mainCircle.x + Math.cos(angle) * (mainCircle.radius - triangleHeight / 2);
            const cy = mainCircle.y + Math.sin(angle) * (mainCircle.radius - triangleHeight / 2);

            ctx.save(); // Guarda el estado del contexto
            ctx.translate(cx, cy); // Mueve el origen al centro del triángulo
            ctx.rotate(angle + Math.PI / 2); // Gira para apuntar hacia el centro del círculo

            ctx.beginPath();
            ctx.moveTo(0, -triangleHeight / 2); // Parte superior del triángulo
            ctx.lineTo(-triangleBase / 2, triangleHeight / 2); // Esquina inferior izquierda
            ctx.lineTo(triangleBase / 2, triangleHeight / 2); // Esquina inferior derecha
            ctx.closePath();

            ctx.fillStyle = getCurrentRenderColor(PASTEL_COLORS[(i + currentColorIndex) % PASTEL_COLORS.length]); // Apply color mode here
            ctx.fill();
            ctx.restore(); // Restaura el estado del contexto
        }
    }

    /** Dibuja los marcadores (bolas objetivo) para que el jugador los golpee. */
    function drawMarkers() {
      const centerX = mainCircle.x;
      const centerY = mainCircle.y;
      const radius = mainCircle.radius;
      const markerRadius = radius * 0.05; // Tamaño del marcador activo más grande
        
      gameState.activeMarkers.forEach(marker => {
        if (marker.hit) {
            ctx.beginPath();
            ctx.arc(
                centerX + Math.cos(marker.originalAngle * DEG_TO_RAD) * radius, // Usa DEG_TO_RAD
                centerY + Math.sin(marker.originalAngle * DEG_TO_RAD) * radius, // Usa DEG_TO_RAD
                mainCircle.radius * 0.035, // Ligeramente más grande cuando se golpea para visibilidad
                0, Math.PI * 2
            );
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; // Blanco desvanecido para marcadores golpeados
            ctx.fill();
            return;
        }

        const radian = marker.angle * DEG_TO_RAD; // Usa DEG_TO_RAD
        const x = centerX + Math.cos(radian) * radius;
        const y = centerY + Math.sin(radian) * radius;

        ctx.beginPath();
        ctx.arc(x, y, markerRadius, 0, Math.PI * 2);
        ctx.fillStyle = getCurrentRenderColor(PASTEL_COLORS[(currentColorIndex + 2) % PASTEL_COLORS.length]); // Apply color mode here
        ctx.fill();
        ctx.strokeStyle = var_to_rgb('--main-border-color'); // Color de borde consistente
        ctx.lineWidth = 4; // Borde más grueso
        ctx.stroke();
      });
    }

    /** Actualiza el ángulo y el rastro del jugador. */
    function updatePlayer(deltaTime) {
      const round = rounds[gameState.currentRoundIndex];
      if (!round) return;

      // Lógica de BPM: Cada BPM ahora equivale a media rotación de círculo (180 grados)
      const degreesPerBeat = 180 / round.beatsPerRotation;
      gameState.player.angle += (degreesPerBeat * (round.bpm / 60)) * (deltaTime / 1000);

      gameState.player.trail.push({
        angle: gameState.player.angle,
        alpha: 1,
        color: getCurrentRenderColor(PASTEL_COLORS[(currentColorIndex + 3) % PASTEL_COLORS.length]) // Apply color mode here
      });

      if (gameState.player.trail.length > TRAIL_LENGTH) {
        gameState.player.trail.shift();
      }
    }

    /** Dibuja el rastro del jugador. */
    function drawTrail() {
      for (let i = 0; i < gameState.player.trail.length; i++) {
        const pos = gameState.player.trail[i];
        const alpha = (i / TRAIL_LENGTH) * 0.7;
        const radian = pos.angle * DEG_TO_RAD; // Usa DEG_TO_RAD
        const x = mainCircle.x + Math.cos(radian) * mainCircle.radius;
        const y = mainCircle.y + Math.sin(radian) * mainCircle.radius;
        const size = gameState.player.radius * (0.1 + (i / TRAIL_LENGTH * 0.8));

        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${hexToRgb(pos.color)},${alpha})`;
        ctx.fill();
      }
    }

    /** Dibuja el círculo del jugador. */
    function drawPlayer() {
      const radian = gameState.player.angle * DEG_TO_RAD; // Usa DEG_TO_RAD
      const x = mainCircle.x + Math.cos(radian) * mainCircle.radius;
      const y = mainCircle.y + Math.sin(radian) * mainCircle.radius;

      ctx.beginPath();
      ctx.arc(x, y, gameState.player.radius, 0, Math.PI * 2);
      ctx.fillStyle = getCurrentRenderColor(PASTEL_COLORS[currentColorIndex]); // Apply color mode here
      ctx.fill();
      ctx.strokeStyle = var_to_rgb('--main-border-color'); // Color de borde consistente
      ctx.lineWidth = 4; // Borde más grueso
      ctx.stroke();
    }

    /** Dibuja y actualiza las partículas. */
    function drawParticles() {
      gameState.particles = gameState.particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.alpha -= 0.03;
        particle.size *= 0.98;

        ctx.fillStyle = `rgba(${hexToRgb(particle.color)},${particle.alpha})`;
        if (particle.isSquare) {
            ctx.fillRect(particle.x - particle.size / 2, particle.y - particle.size / 2, particle.size, particle.size);
        } else {
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
        }

        return particle.alpha > 0 && particle.size > 0.5;
      });
    }

    /** Dibuja y actualiza los textos de retroalimentación de golpe. */
    // NOTA: Las tres funciones de dibujo de texto de retroalimentación son muy similares.
    // Se mantienen separadas para mayor claridad, ya que su lógica de animación (tamaño de fuente, movimiento) difiere ligeramente.
    // Se podría hacer una única función genérica, pero agregaría complejidad.
    function drawHitFeedbackTexts(deltaTime) {
      gameState.hitFeedbackTexts = gameState.hitFeedbackTexts.filter(textObj => {
        const elapsed = gameState.globalTime - textObj.startTime;
        textObj.alpha = 1 - (elapsed / HIT_TEXT_LIFETIME);
        textObj.y -= deltaTime * 0.05;

        if (textObj.alpha > 0) {
          ctx.fillStyle = `rgba(${hexToRgb(textObj.color)}, ${textObj.alpha})`;
          ctx.font = `bold ${25 * textObj.alpha + 10}px Inter`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(textObj.text, textObj.x, textObj.y);
          return true;
        }
        return false;
      });
    }

    /** Dibuja y actualiza los textos de retroalimentación de combo. */
    function drawComboFeedbackTexts(deltaTime) {
        gameState.comboFeedbackTexts = gameState.comboFeedbackTexts.filter(textObj => {
            const elapsed = gameState.globalTime - textObj.startTime;
            textObj.alpha = 1 - (elapsed / COMBO_TEXT_LIFETIME);
            textObj.y -= deltaTime * 0.04; // Flotación ligeramente más lenta

            if (textObj.alpha > 0) {
                ctx.fillStyle = `rgba(${hexToRgb(textObj.color)}, ${textObj.alpha})`;
                ctx.font = `bold ${30 * textObj.alpha + 15}px Inter`; // Fuente más grande y desvanecida
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(textObj.text, textObj.x, textObj.y);
                return true;
            }
            return false;
        });
    }

    /** Dibuja y actualiza los textos de ronda completada. */
    function drawRoundCompleteTexts(deltaTime) {
        gameState.roundCompleteTexts = gameState.roundCompleteTexts.filter(textObj => {
            const elapsed = gameState.globalTime - textObj.startTime;
            textObj.alpha = 1 - (elapsed / ROUND_COMPLETE_TEXT_LIFETIME);
            // Mantiene el texto centrado, no lo mueve verticalmente
            if (textObj.alpha > 0) {
                ctx.fillStyle = `rgba(${hexToRgb(textObj.color)}, ${textObj.alpha})`;
                ctx.font = `bold ${40 * textObj.alpha + 20}px Inter`; // Fuente grande y desvanecida
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(textObj.text, textObj.x, textObj.y);
                return true;
            }
            return false;
        });
    }

    /**
     * Dibuja y actualiza los cuadrados y líneas de fondo en el canvas principal.
     * @param {number} deltaTime - Tiempo transcurrido desde el último fotograma.
     */
    function drawBackgroundElements(deltaTime) {
        ctx.save();
        
        // Obtiene las dimensiones actuales del canvas para envolver los elementos
        const currentCanvasWidth = window.innerWidth;
        const currentCanvasHeight = window.innerHeight;

        // Dibuja y actualiza los cuadrados
        backgroundSquares.forEach(square => {
            square.x += square.moveSpeedX * deltaTime;
            square.y += square.moveSpeedY * deltaTime;
            square.rotation += square.rotationSpeed * deltaTime;

            // Envuelve los cuadrados si se salen de los límites del canvas
            if (square.x > currentCanvasWidth + square.size) square.x = -square.size;
            if (square.x < -square.size) square.x = currentCanvasWidth + square.size;
            if (square.y > currentCanvasHeight + square.size) square.y = -square.size;
            if (square.y < -square.size) square.y = currentCanvasHeight + square.size;

            ctx.save();
            ctx.translate(square.x, square.y);
            ctx.rotate(square.rotation);
            ctx.fillStyle = `rgba(${hexToRgb(getCurrentRenderColor(square.color))}, ${square.alpha})`; // Apply color mode here
            ctx.fillRect(-square.size / 2, -square.size / 2, square.size, square.size);
            ctx.restore();
        });

        // Dibuja y actualiza las líneas
        backgroundLines.forEach(line => {
            // Las líneas se mueven en función de su ángulo y velocidad para una dirección consistente
            line.x += Math.cos(line.angle) * line.moveSpeed * deltaTime;
            line.y += Math.sin(line.angle) * line.moveSpeed * deltaTime;
            line.angle += line.rotationSpeed * deltaTime; // Las líneas también pueden rotar lentamente

            // Envuelve las líneas
            if (line.x > currentCanvasWidth + line.length) line.x = -line.length;
            if (line.x < -line.length) line.x = currentCanvasWidth + line.length;
            if (line.y > currentCanvasHeight + line.length) line.y = -line.length;
            if (line.y < -line.size) line.y = currentCanvasHeight + line.length;

            ctx.save();
            ctx.translate(line.x, line.y);
            ctx.rotate(line.angle);
            ctx.strokeStyle = `rgba(${hexToRgb(getCurrentRenderColor(line.color))}, ${line.alpha})`; // Apply color mode here
            ctx.lineWidth = 2; // Ancho de línea fijo
            ctx.beginPath();
            ctx.moveTo(-line.length / 2, 0);
            ctx.lineTo(line.length / 2, 0);
            ctx.stroke();
            ctx.restore();
        });

        ctx.restore();
    }

    /** Aplica el efecto de shader de Aberración Cromática y Brillo de Movimiento. */
    function applyChromaticGlowShader() {
        // Verifica si el shader está activo antes de realizar cualquier cálculo
        if (gameState.activeShader !== 'chromatic_glow') return;
        
        // Asegura que tempCanvas y tempCtx estén inicializados y dimensionados correctamente
        if (!tempCanvas || tempCanvas.width !== canvas.width || tempCanvas.height !== canvas.height) {
            setCanvasSize(); // Reinicializa si es necesario
        }

        // Agrega una verificación aquí para las dimensiones del canvas principal antes de dibujar
        if (canvas.width === 0 || canvas.height === 0) {
            console.error("Las dimensiones del canvas son cero, no se puede aplicar el shader.");
            return; // Evita dibujar si el canvas no es válido
        }

        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
        tempCtx.drawImage(canvas, 0, 0); // Dibuja el contenido actual del canvas principal en el canvas temporal

        // Limpia el canvas principal para redibujar con el efecto
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.save(); // Guarda el estado del contexto
        ctx.globalCompositeOperation = 'lighter'; 
        
        const glowBlur = 0.5; // Desenfoque reducido para un brillo de movimiento mínimo

        // Anima el desplazamiento para la aberración cromática
        // Oscila entre -2 y 2, para un efecto más pronunciado
        const animatedOffset = Math.sin(gameState.globalTime * 0.002) * 2; 

        // Dibuja capas con efectos
        const layers = [
            // Capa Roja: se mueve en la dirección positiva del offset
            { offsetX: animatedOffset, offsetY: animatedOffset, filter: `blur(${glowBlur}px)`, hueRotate: 0, brightness: 1.2, saturate: 1.5 }, 
            // Capa Verde (central): sin desplazamiento, ligeramente desenfocada
            { offsetX: 0, offsetY: 0, filter: `blur(${glowBlur * 0.5}px)`, hueRotate: 120, brightness: 1.1, saturate: 1.2 }, 
            // Capa Azul: se mueve en la dirección negativa del offset
            { offsetX: -animatedOffset, offsetY: -animatedOffset, filter: `blur(${glowBlur}px)`, hueRotate: 240, brightness: 1.2, saturate: 1.5 } 
        ];
        
        layers.forEach(layer => {
            ctx.filter = `blur(${layer.filter}) hue-rotate(${layer.hueRotate}deg) brightness(${layer.brightness}) saturate(${layer.saturate})`;
            ctx.drawImage(tempCanvas, layer.offsetX, layer.offsetY);
        });
        
        ctx.restore(); // Restaura el estado del contexto para restablecer globalCompositeOperation y filter
    }

    /** Dibuja todos los elementos centrales del juego para Canvas 2D. */
    function drawCoreGameElements2D(deltaTime) {
        drawCentralReel();
        drawInnerBorderTriangles();
        drawMarkers();
        updatePlayer(deltaTime);
        drawTrail();
        drawPlayer();
        drawParticles();
        drawHitFeedbackTexts(deltaTime);
        drawComboFeedbackTexts(deltaTime);
        drawRoundCompleteTexts(deltaTime);
    }

    // --- WebGL Rendering ---
    const vertexShaderSource = `
        attribute vec2 a_position;
        uniform vec2 u_resolution;
        void main() {
            // convierte la posición de píxeles a 0.0 a 1.0
            vec2 zeroToOne = a_position / u_resolution;
            // convierte de 0->1 a 0->2
            vec2 zeroToTwo = zeroToOne * 2.0;
            // convierte de 0->2 a -1->+1 (espacio de recorte)
            vec2 clipSpace = zeroToTwo - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
    `;

    const fragmentShaderSource = `
        precision mediump float;
        uniform vec4 u_color;
        void main() {
            gl_FragColor = u_color;
        }
    `;

    // FXAA Shaders
    const fxaaVertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        void main() {
            gl_Position = vec4(a_position, 0, 1);
            v_texCoord = (a_position * 0.5) + 0.5; // Convert clip space to texture space (0 to 1)
        }
    `;
    const fxaaFragmentShaderSource = `
        precision mediump float;
        uniform sampler2D u_sampler;
        uniform vec2 u_resolution;
        varying vec2 v_texCoord;

        #define FXAA_REDUCE_MIN (1.0/128.0)
        #define FXAA_REDUCE_MUL (1.0/8.0)
        #define FXAA_SPAN_MAX 8.0

        void main() {
            vec3 rgbNW = texture2D(u_sampler, v_texCoord + (vec2(-1.0, -1.0) / u_resolution)).xyz;
            vec3 rgbNE = texture2D(u_sampler, v_texCoord + (vec2(1.0, -1.0) / u_resolution)).xyz;
            vec3 rgbSW = texture2D(u_sampler, v_texCoord + (vec2(-1.0, 1.0) / u_resolution)).xyz;
            vec3 rgbSE = texture2D(u_sampler, v_texCoord + (vec2(1.0, 1.0) / u_resolution)).xyz;
            vec3 rgbM  = texture2D(u_sampler, v_texCoord).xyz;

            vec3 luma = vec3(0.299, 0.587, 0.114);
            float lumaNW = dot(rgbNW, luma);
            float lumaNE = dot(rgbNE, luma);
            float lumaSW = dot(rgbSW, luma);
            float lumaSE = dot(rgbSE, luma);
            float lumaM  = dot(rgbM,  luma);

            float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
            float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

            vec2 dir;
            dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
            dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

            float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
            float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
            dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
                      max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                      dir * rcpDirMin)) / u_resolution;

            vec3 rgbA = 0.5 * (
                texture2D(u_sampler, v_texCoord + dir * (1.0/3.0 - 0.5)).xyz +
                texture2D(u_sampler, v_texCoord + dir * (2.0/3.0 - 0.5)).xyz);
            vec3 rgbB = rgbA * 0.5 + 0.25 * (
                texture2D(u_sampler, v_texCoord + dir * -0.5).xyz +
                texture2D(u_sampler, v_texCoord + dir * 0.5).xyz);

            float lumaB = dot(rgbB, luma);
            if ((lumaB < lumaMin) || (lumaB > lumaMax)) {
                gl_FragColor = vec4(rgbA, 1.0);
            } else {
                gl_FragColor = vec4(rgbB, 1.0);
            }
        }
    `;


    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
            return shader;
        }
        console.error('Error de compilación de shader:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return undefined;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        const success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
            return program;
        }
        console.error('Error de enlace de programa:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return undefined;
    }

    function initWebGL() {
        // Try to get WebGL2, fallback to WebGL1, then fail.
        // Disable default anti-aliasing if we plan to use custom AA
        gl = canvas.getContext('webgl2', { antialias: false }) || canvas.getContext('webgl', { antialias: false }); 
        if (!gl) {
            customAlert('Error', 'WebGL no es soportado por tu navegador.');
            setRenderer('2d'); // Fallback to 2D
            return false;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        if (!vertexShader || !fragmentShader) return false;

        webglData.program = createProgram(gl, vertexShader, fragmentShader);
        if (!webglData.program) return false;

        webglData.positionAttributeLocation = gl.getAttribLocation(webglData.program, "a_position");
        webglData.resolutionUniformLocation = gl.getUniformLocation(webglData.program, "u_resolution");
        webglData.colorUniformLocation = gl.getUniformLocation(webglData.program, "u_color");

        webglData.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, webglData.positionBuffer);

        // Clear previous FBOs and textures if re-initializing
        if (webglData.msaaFramebuffer) gl.deleteFramebuffer(webglData.msaaFramebuffer);
        if (webglData.msaaRenderbuffer) gl.deleteRenderbuffer(webglData.msaaRenderbuffer);
        if (webglData.msaaTexture) gl.deleteTexture(webglData.msaaTexture);
        if (webglData.sceneTextureFramebuffer) gl.deleteFramebuffer(webglData.sceneTextureFramebuffer);
        if (webglData.sceneTexture) gl.deleteTexture(webglData.sceneTexture);
        if (webglData.fxaaProgram) gl.deleteProgram(webglData.fxaaProgram);
        if (webglData.quadBuffer) gl.deleteBuffer(webglData.quadBuffer);

        webglData.msaaFramebuffer = null;
        webglData.msaaRenderbuffer = null;
        webglData.msaaTexture = null;
        webglData.sceneTextureFramebuffer = null;
        webglData.sceneTexture = null;
        webglData.fxaaProgram = null;
        webglData.quadBuffer = null;

        // Setup for MSAA (WebGL2 only)
        if (gl instanceof WebGL2RenderingContext && gameState.currentAntiAliasing === 'msaa_x2') {
            webglData.msaaFramebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, webglData.msaaFramebuffer);

            webglData.msaaRenderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, webglData.msaaRenderbuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 2, gl.RGBA8, canvas.width, canvas.height); // MSAA x2
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, webglData.msaaRenderbuffer);

            const fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (fbStatus !== gl.FRAMEBUFFER_COMPLETE) {
                console.error('MSAA Framebuffer not complete:', fbStatus);
                gameState.currentAntiAliasing = 'none'; // Fallback
                customAlert('Advertencia', 'MSAA x2 no pudo ser inicializado. Usando sin Anti-Aliasing.');
                gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Unbind FBO
                return initWebGL(); // Re-initialize without MSAA
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Unbind FBO
        }

        // Setup for FXAA
        if (gameState.currentAntiAliasing === 'fxaa') {
            // Create a texture to render the scene into
            webglData.sceneTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, webglData.sceneTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); // Added for better quality
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // Create a framebuffer to attach the texture
            webglData.sceneTextureFramebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, webglData.sceneTextureFramebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, webglData.sceneTexture, 0);

            const fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (fbStatus !== gl.FRAMEBUFFER_COMPLETE) {
                console.error('FXAA Texture Framebuffer not complete:', fbStatus);
                gameState.currentAntiAliasing = 'none'; // Fallback
                customAlert('Advertencia', 'FXAA no pudo ser inicializado. Usando sin Anti-Aliasing.');
                gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Unbind FBO
                return initWebGL(); // Re-initialize without FXAA
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Unbind FBO

            // Initialize FXAA shaders
            const fxaaVertexShader = createShader(gl, gl.VERTEX_SHADER, fxaaVertexShaderSource);
            const fxaaFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fxaaFragmentShaderSource);
            if (!fxaaVertexShader || !fxaaFragmentShader) return false;

            webglData.fxaaProgram = createProgram(gl, fxaaVertexShader, fxaaFragmentShader);
            if (!webglData.fxaaProgram) return false;

            webglData.fxaaPositionLocation = gl.getAttribLocation(webglData.fxaaProgram, "a_position");
            webglData.fxaaResolutionUniform = gl.getUniformLocation(webglData.fxaaProgram, "u_resolution");
            webglData.fxaaSamplerUniform = gl.getUniformLocation(webglData.fxaaProgram, "u_sampler");

            // Create a buffer for a fullscreen quad
            webglData.quadBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, webglData.quadBuffer);
            const positions = [
                -1, -1, // bottom-left
                 1, -1, // bottom-right
                -1,  1, // top-left
                -1,  1, // top-left
                 1, -1, // bottom-right
                 1,  1, // top-right
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        }

        return true;
    }

    function drawCircleWebGL(centerX, centerY, radius, color) {
        const segments = 32;
        const vertices = [centerX, centerY];
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * 2 * Math.PI;
            vertices.push(centerX + Math.cos(angle) * radius);
            vertices.push(centerY + Math.sin(angle) * radius);
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        
        const normalizedColor = hexToRgbNormalized(color);
        gl.uniform4f(webglData.colorUniformLocation, normalizedColor[0], normalizedColor[1], normalizedColor[2], 1);
        
        gl.drawArrays(gl.TRIANGLE_FAN, 0, segments + 2);
    }

    function drawCoreGameElementsWebGL(deltaTime) {
        // Dibuja el borde del círculo principal (como un círculo blanco ligeramente más grande detrás)
        drawCircleWebGL(mainCircle.x, mainCircle.y, mainCircle.radius + 6, '#FFFFFF');

        // Dibuja al jugador
        const playerRadian = gameState.player.angle * DEG_TO_RAD;
        const playerX = mainCircle.x + Math.cos(playerRadian) * mainCircle.radius;
        const playerY = mainCircle.y + Math.sin(playerRadian) * mainCircle.radius;
        drawCircleWebGL(playerX, playerY, getCurrentRenderColor(PASTEL_COLORS[currentColorIndex])); // Apply color mode here
        
        // Dibuja los marcadores
        const markerRadius = mainCircle.radius * 0.05;
        gameState.activeMarkers.forEach(marker => {
            const markerRadian = marker.angle * DEG_TO_RAD;
            const markerX = mainCircle.x + Math.cos(markerRadian) * mainCircle.radius;
            const markerY = mainCircle.y + Math.sin(markerRadian) * mainCircle.radius;
            const color = marker.hit ? '#333333' : getCurrentRenderColor(PASTEL_COLORS[(currentColorIndex + 2) % PASTEL_COLORS.length]); // Apply color mode here
            drawCircleWebGL(markerX, markerY, markerRadius, color);
        });
        
        updatePlayer(deltaTime);
    }

    function drawWebGL(timestamp, deltaTime) {
        if (!gl) return;

        // Determine target framebuffer for rendering the scene
        let targetFramebuffer = null;
        if (gl instanceof WebGL2RenderingContext && gameState.currentAntiAliasing === 'msaa_x2') {
            targetFramebuffer = webglData.msaaFramebuffer;
        } else if (gameState.currentAntiAliasing === 'fxaa') {
            targetFramebuffer = webglData.sceneTextureFramebuffer;
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, targetFramebuffer);
        gl.viewport(0, 0, canvas.width, canvas.height); // Use canvas.width/height for FBOs
        gl.clearColor(0.05, 0.05, 0.05, 1.0); // Dark grey background
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        gl.useProgram(webglData.program);
        gl.enableVertexAttribArray(webglData.positionAttributeLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, webglData.positionBuffer);
        gl.vertexAttribPointer(webglData.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        gl.uniform2f(webglData.resolutionUniformLocation, canvas.width, canvas.height); // Use FBO dimensions

        if (gameState.phase === 'playing' || gameState.phase === 'paused' || gameState.phase === 'ended' || gameState.phase === 'roundComplete') {
            drawCoreGameElementsWebGL(deltaTime);
        }

        // Post-processing for anti-aliasing
        if (gl instanceof WebGL2RenderingContext && gameState.currentAntiAliasing === 'msaa_x2') {
            // Blit multisampled framebuffer to default framebuffer
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webglData.msaaFramebuffer);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null); // Default framebuffer
            gl.clearBufferfv(gl.COLOR, 0, [0.05, 0.05, 0.05, 1.0]); // Clear default buffer before blit
            gl.blitFramebuffer(
                0, 0, canvas.width, canvas.height,
                0, 0, canvas.width, canvas.height,
                gl.COLOR_BUFFER_BIT, gl.NEAREST
            );
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null); // Unbind READ_FRAMEBUFFER
        } else if (gameState.currentAntiAliasing === 'fxaa') {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Render to default framebuffer
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // Back to viewport dimensions
            gl.clearColor(0.05, 0.05, 0.05, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(webglData.fxaaProgram);
            gl.enableVertexAttribArray(webglData.fxaaPositionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, webglData.quadBuffer);
            gl.vertexAttribPointer(webglData.fxaaPositionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(webglData.fxaaResolutionUniform, canvas.width, canvas.height);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, webglData.sceneTexture);
            gl.uniform1i(webglData.fxaaSamplerUniform, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6); // Draw the fullscreen quad
        }
    }


    // --- Render Loop ---
    /**
     * Bucle principal de renderizado y actualización del juego.
     * @param {DOMHighResTimeStamp} timestamp - El tiempo actual proporcionado por requestAnimationFrame.
     */
    function draw(timestamp) {
      if (!gameState.lastTime) gameState.lastTime = timestamp;
      const deltaTime = timestamp - gameState.lastTime;
      gameState.lastTime = timestamp;
      
      // Solo actualiza el tiempo global si no está en pausa
      if (gameState.phase !== 'paused') {
        gameState.globalTime += deltaTime;
      }

      if (gameState.currentRenderer === 'webgl') {
          drawWebGL(timestamp, deltaTime);
          requestAnimationFrame(draw);
          return;
      }

      // --- RENDERIZADO DE CANVAS 2D ---
      if (!ctx) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Siempre limpia todo el canvas para manejar correctamente los elementos de fondo animados

      // Solo dibuja los elementos visuales específicos del juego si NO está en el menú principal, configuración o pantalla de puntuación.
      if (gameState.phase !== 'menu' && gameState.phase !== 'settings' && gameState.phase !== 'scoreScreen') {
        // Dibuja los elementos visuales comunes del juego (fondo y borde del círculo principal)
        drawBackgroundElements(deltaTime); // Los elementos de fondo se animan incluso cuando están en pausa

        ctx.beginPath();
        ctx.arc(mainCircle.x, mainCircle.y, mainCircle.radius + 6, 0, Math.PI * 2); // Parte exterior del borde
        ctx.strokeStyle = '#FFFFFF'; // Cambiado a blanco
        ctx.lineWidth = 12; // Coincide visualmente con el tamaño del borde CSS
        ctx.stroke();

        // Renderiza los elementos del juego según la fase actual
        if (gameState.phase === 'playing') {
          drawCoreGameElements2D(deltaTime);
        } else if (gameState.phase === 'roundComplete') {
          drawCoreGameElements2D(deltaTime);
          
          // Verifica si es hora de iniciar la siguiente ronda
          if (gameState.globalTime >= gameState.nextRoundStartTime) {
            gameState.currentRoundIndex++;
            startRound(gameState.currentRoundIndex); // Llama a showScoreScreen si todas las rondas están hechas
            if (gameState.phase !== 'scoreScreen') { // Solo establece como jugando si no está en transición a la pantalla de puntuación
                gameState.phase = 'playing';
            }
          }
        } else if (gameState.phase === 'paused' || gameState.phase === 'ended') {
            // Cuando está en pausa o finalizado, dibuja los elementos estáticos del juego (sin actualizaciones para la lógica central del juego,
            // pero las animaciones transitorias como partículas/textos aún progresan).
            drawCoreGameElements2D(deltaTime);
        } else if (gameState.phase === 'introAnimation') {
            const elapsed = gameState.globalTime - gameState.introAnimationStartTime;
            const progress = Math.min(1, elapsed / INTRO_ANIMATION_DURATION);

            // Escala el círculo principal y el carrete central durante la introducción
            const initialRadius = 0;
            const targetRadius = mainCircle.radius;
            const currentRadius = initialRadius + (targetRadius - initialRadius) * progress;

            // Sobreescribe temporalmente mainCircle.radius para dibujar
            const originalMainCircleRadius = mainCircle.radius;
            mainCircle.radius = currentRadius;

            // Dibuja el carrete central escalado y el borde del círculo principal
            drawCentralReel();
            ctx.beginPath();
            ctx.arc(mainCircle.x, mainCircle.y, mainCircle.radius + 6, 0, Math.PI * 2);
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 12;
            ctx.stroke();

            // Restaura el mainCircle.radius original
            mainCircle.radius = originalMainCircleRadius;

            if (elapsed >= INTRO_ANIMATION_DURATION) {
                elements.introAnimationText.classList.remove('animate-intro'); // Elimina la clase para permitir la re-animación
                elements.introAnimationText.classList.add('hidden'); // Oculta el texto de introducción
                gameState.phase = 'playing';
                gameState.startTime = gameState.globalTime;
                resetGameStats();
                startRound(0);
                setTimeout(hideGameInfoText, 5000);
            }
        }

        // Aplica el efecto de shader si está habilitado, al final del dibujo
        if (gameState.activeShader === 'invert') {
            ctx.filter = 'invert(100%)';
        } else if (gameState.activeShader === 'chromatic_glow') {
            applyChromaticGlowShader();
        } else {
            ctx.filter = 'none';
        }
      }

      requestAnimationFrame(draw); // Solicita el siguiente fotograma de animación
    }


    // --- Settings Functions ---
    /**
     * Establece el renderizador.
     * @param {string} renderer - El renderizador a usar ('2d' o 'webgl').
     */
    function setRenderer(renderer) {
        if (renderer === 'webgl') {
            if (!gl || gameState.currentRenderer !== 'webgl') { // Only re-initialize if not already webgl or gl is null
                if (!initWebGL()) {
                    return; // If WebGL init failed, don't switch
                }
            }
            ctx = null; // We are no longer using 2D context
        } else {
            ctx = canvas.getContext('2d');
            // Apply 2D anti-aliasing setting
            ctx.imageSmoothingEnabled = gameState.imageSmoothingEnabled;

            // If switching from WebGL, ensure to clean up WebGL resources
            if (gl) {
                if (webglData.msaaFramebuffer) gl.deleteFramebuffer(webglData.msaaFramebuffer);
                if (webglData.msaaRenderbuffer) gl.deleteRenderbuffer(webglData.msaaRenderbuffer);
                if (webglData.msaaTexture) gl.deleteTexture(webglData.msaaTexture);
                if (webglData.sceneTextureFramebuffer) gl.deleteFramebuffer(webglData.sceneTextureFramebuffer);
                if (webglData.sceneTexture) gl.deleteTexture(webglData.sceneTexture);
                if (webglData.fxaaProgram) gl.deleteProgram(webglData.fxaaProgram);
                if (webglData.quadBuffer) gl.deleteBuffer(webglData.quadBuffer);
                gl = null; // Clear gl context
            }
        }
        gameState.currentRenderer = renderer;
        updateSettingsUI();
        saveSettings();
        setCanvasSize(); // Re-run to set correct context scaling
    }

    /**
     * Establece la calidad de los gráficos y actualiza los parámetros relacionados.
     * @param {string} quality - La calidad de gráficos deseada ('low', 'medium', 'high').
     */
    function setGraphicsQuality(quality) {
        gameState.currentGraphicsQuality = quality;
        NUM_BACKGROUND_SQUARES = GRAPHICS_SETTINGS[quality].squares;
        PARTICLES_COUNT = GRAPHICS_SETTINGS[quality].particles;
        NUM_BACKGROUND_LINES = GRAPHICS_SETTINGS[quality].lines; // Actualiza el recuento de líneas
        initializeBackgroundElements(); // Reinicializa los elementos con los nuevos recuentos
        updateSettingsUI(); // Actualiza el botón activo en la UI
        saveSettings(); // Guarda la configuración después del cambio
    }

    /**
     * Establece la dificultad del juego.
     * @param {string} difficulty - La dificultad deseada ('easy', 'normal', 'hard').
     */
    function setDifficulty(difficulty) {
        gameState.currentDifficulty = difficulty;
        updateSettingsUI(); // Actualiza el botón activo en la UI
        saveSettings(); // Guarda la configuración después del cambio
    }

    /**
     * Establece el efecto de shader activo.
     * @param {string} effectType - El tipo de shader a activar ('none', 'invert', 'chromatic_glow').
     */
    function setShaderEffect(effectType) {
        gameState.activeShader = effectType;
        updateSettingsUI(); // Actualiza el botón activo en la UI
        saveSettings(); // Guarda la configuración después del cambio
    }

    /**
     * Establece el modo de color para el juego.
     * @param {string} mode - El modo de color deseado ('per_round', 'rainbow', 'monochromatic').
     */
    function setColorMode(mode) {
        gameState.colorMode = mode;
        if (mode === 'rainbow') {
            if (!colorUpdateIntervalId) { // Solo inicia si aún no está en ejecución
                colorUpdateIntervalId = setInterval(updatePsychedelicColors, 700);
            }
        } else {
            clearInterval(colorUpdateIntervalId); // Detiene el cambio automático de color
            colorUpdateIntervalId = null;
            // Para 'per_round' o 'monochromatic', el color se establece en startRound() o getCurrentRenderColor()
        }
        updateSettingsUI(); // Actualiza el botón activo en la UI
        saveSettings(); // Guarda la configuración después del cambio
    }

    /**
     * Establece el modo de anti-aliasing para Canvas 2D.
     * @param {boolean} enabled - Verdadero para anti-aliasing suave, falso para pixelado.
     */
    function setImageSmoothing(enabled) {
        gameState.imageSmoothingEnabled = enabled;
        if (gameState.currentRenderer === '2d' && ctx) {
            ctx.imageSmoothingEnabled = enabled;
        }
        updateSettingsUI();
        saveSettings();
    }

    /**
     * Establece el modo de anti-aliasing para WebGL.
     * @param {string} mode - El modo de anti-aliasing a activar ('none', 'msaa_x2', 'fxaa').
     */
    function setAntiAliasing(mode) {
        if (gameState.currentAntiAliasing === mode) return; // No change needed

        // If switching to MSAA or FXAA, or from them, re-initialize WebGL context
        const requiresReinit = (mode === 'msaa_x2' || mode === 'fxaa' || gameState.currentAntiAliasing === 'msaa_x2' || gameState.currentAntiAliasing === 'fxaa');

        gameState.currentAntiAliasing = mode;
        if (requiresReinit && gameState.currentRenderer === 'webgl') {
            // Force re-initialization of WebGL context
            setRenderer('webgl'); // This will call initWebGL internally and clean up
        } else if (gameState.currentRenderer === '2d') {
            // If in 2D mode, just update the setting, it will apply if they switch to WebGL later
            updateSettingsUI();
            saveSettings();
        } else { // Already in WebGL, but not switching AA modes that require full reinit
            updateSettingsUI();
            saveSettings();
        }
    }

    /** Actualiza la clase 'active' para los botones en la UI de configuración. */
    function updateSettingsUI() {
        // Botones de renderizador
        elements.renderer2d.classList.toggle('active', gameState.currentRenderer === '2d');
        elements.rendererWebGL.classList.toggle('active', gameState.currentRenderer === 'webgl');

        // Botones de gráficos
        elements.graphicsLow.classList.toggle('active', gameState.currentGraphicsQuality === 'low');
        elements.graphicsMedium.classList.toggle('active', gameState.currentGraphicsQuality === 'medium');
        elements.graphicsHigh.classList.toggle('active', gameState.currentGraphicsQuality === 'high');

        // Botones de dificultad
        elements.difficultyEasy.classList.toggle('active', gameState.currentDifficulty === 'easy');
        elements.difficultyNormal.classList.toggle('active', gameState.currentDifficulty === 'normal');
        elements.difficultyHard.classList.toggle('active', gameState.currentDifficulty === 'hard');

        // Botones de shader
        elements.shaderOff.classList.toggle('active', gameState.activeShader === 'none');
        elements.shaderInvert.classList.toggle('active', gameState.activeShader === 'invert');
        elements.shaderChromaticGlow.classList.toggle('active', gameState.activeShader === 'chromatic_glow');

        // Botones de modo de color
        elements.colorModePerRound.classList.toggle('active', gameState.colorMode === 'per_round');
        elements.colorModeRainbow.classList.toggle('active', gameState.colorMode === 'rainbow');
        elements.colorModeMonochromatic.classList.toggle('active', gameState.colorMode === 'monochromatic'); // New monochromatic button

        // 2D Anti-Aliasing buttons
        elements.imageSmoothingSmooth.classList.toggle('active', gameState.imageSmoothingEnabled === true);
        elements.imageSmoothingPixelated.classList.toggle('active', gameState.imageSmoothingEnabled === false);

        // WebGL Anti-Aliasing buttons
        elements.antiAliasingNone.classList.toggle('active', gameState.currentAntiAliasing === 'none');
        elements.antiAliasingMSAAx2.classList.toggle('active', gameState.currentAntiAliasing === 'msaa_x2');
        elements.antiAliasingFXAA.classList.toggle('active', gameState.currentAntiAliasing === 'fxaa');
    }

    /** Hides the game info text after a delay. */
    function hideGameInfoText() {
        elements.gameInfoText.classList.add('hidden');
    }

    /** Shows the game info text. */
    function showGameInfoText() {
        elements.gameInfoText.classList.remove('hidden');
    }

    // --- LocalStorage Functions ---
    /** Guarda la configuración actual del juego en localStorage. */
    function saveSettings() {
        const settings = {
            renderer: gameState.currentRenderer,
            graphics: gameState.currentGraphicsQuality,
            difficulty: gameState.currentDifficulty,
            shader: gameState.activeShader,
            colorMode: gameState.colorMode,
            imageSmoothingEnabled: gameState.imageSmoothingEnabled, // Save new 2D AA setting
            antiAliasing: gameState.currentAntiAliasing // Save WebGL AA setting
        };
        localStorage.setItem('rpcgSettings', JSON.stringify(settings));
    }

    /** Carga la configuración del juego desde localStorage. */
    function loadSettings() {
        const savedSettings = localStorage.getItem('rpcgSettings');
        if (savedSettings) {
            const settings = JSON.parse(savedSettings);
            // Aplica la configuración cargada, asegurando los valores predeterminados si falta una configuración
            setImageSmoothing(settings.imageSmoothingEnabled !== undefined ? settings.imageSmoothingEnabled : true); // Load 2D AA setting first
            setRenderer(settings.renderer || '2d'); // This will apply imageSmoothingEnabled if 2D
            setGraphicsQuality(settings.graphics || 'medium');
            setDifficulty(settings.difficulty || 'normal');
            setShaderEffect(settings.shader || 'none');
            setColorMode(settings.colorMode || 'rainbow');
            setAntiAliasing(settings.antiAliasing || 'none'); // Load WebGL AA setting
        } else {
            // Apply initial defaults if no settings are saved
            setImageSmoothing(true); // Default for 2D anti-aliasing
            setRenderer('2d');
            setGraphicsQuality('medium');
            setDifficulty('normal');
            setShaderEffect('none');
            setColorMode('rainbow');
            setAntiAliasing('none'); // Default for new users
        }
        updateSettingsUI(); // Ensure UI reflects loaded settings
    }

    // --- Event Listener Handlers ---
    /** Maneja la entrada de juego (barra espaciadora o toque). */
    function handleGameplayInput() {
        const currentTime = performance.now();
        if (currentTime - lastGameplayInputTime < GAMEPLAY_INPUT_COOLDOWN) {
            return; 
        }
        lastGameplayInputTime = currentTime;
        checkHit();
        document.querySelectorAll('.hud-item').forEach(item => {
            item.classList.add('animate-pulse');
            setTimeout(() => item.classList.remove('animate-pulse'), 300);
        });
    }

    function handleKeyDown(e) {
        if (e.code === 'Escape') {
            if (gameState.phase === 'playing') {
                gameState.phase = 'paused';
                elements.pauseMenu.classList.remove('hidden');
                elements.gameInfoText.classList.add('hidden'); 
            } else if (gameState.phase === 'paused') {
                gameState.phase = 'playing';
                elements.pauseMenu.classList.add('hidden');
            }
            return;
        }

        if (e.code === 'Space') {
            if (isSpacePressed) {
                return;
            }
            isSpacePressed = true;
            
            if (gameState.phase === 'menu') {
                elements.startMenu.classList.add('hidden');
                elements.introAnimationText.classList.remove('hidden');
                elements.introAnimationText.classList.add('animate-intro'); // Inicia la animación
                gameState.phase = 'introAnimation';
                gameState.introAnimationStartTime = gameState.globalTime;
                // La lógica de inicio del juego se manejará después de que la animación de introducción se complete
            } else if (gameState.phase === 'playing') {
                handleGameplayInput(); // Llama al manejador centralizado de entrada de juego
            }
            e.preventDefault();
        }
    }

    function handleKeyUp(e) {
        if (e.code === 'Space') {
            isSpacePressed = false;
        }
    }

    function handleTouch(e) {
        if (gameState.phase === 'playing') {
            e.preventDefault(); // Evita el comportamiento táctil predeterminado (ej. desplazamiento, zoom)
            handleGameplayInput(); // Llama al manejador centralizado de entrada de juego
        } else if (gameState.phase === 'menu') {
             // Maneja el toque en el botón de reproducción en el menú
            if (e.target === elements.playButton) {
                elements.startMenu.classList.add('hidden');
                elements.introAnimationText.classList.remove('hidden');
                elements.introAnimationText.classList.add('animate-intro'); // Inicia la animación
                gameState.phase = 'introAnimation';
                gameState.introAnimationStartTime = gameState.globalTime;
                e.preventDefault();
            }
        }
    }

    // --- Event Listener Attachments ---
    function setupEventListeners() {
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        document.body.addEventListener('touchstart', handleTouch);
    }

    // Función auxiliar para adjuntar oyentes de clic y touchstart a los botones
    function attachButtonListeners(buttonElement, handlerFunction) {
        buttonElement.addEventListener('click', handlerFunction);
        buttonElement.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Evita el comportamiento táctil predeterminado (ej. clics fantasma)
            handlerFunction(e); // Ejecuta la acción del botón
        });
    }

    // Adjunta oyentes a los botones del menú principal
    attachButtonListeners(elements.playButton, () => {
        elements.startMenu.classList.add('hidden');
        elements.introAnimationText.classList.remove('hidden');
        elements.introAnimationText.classList.add('animate-intro'); // Inicia la animación
        gameState.phase = 'introAnimation';
        gameState.introAnimationStartTime = gameState.globalTime;
    });
    attachButtonListeners(elements.settingsButton, () => {
        elements.startMenu.classList.add('hidden');
        elements.settingsMenu.classList.remove('hidden');
        gameState.phase = 'settings';
        updateSettingsUI();
    });
    attachButtonListeners(elements.backToMainMenuButton, () => {
        elements.settingsMenu.classList.add('hidden');
        elements.startMenu.classList.remove('hidden');
        gameState.phase = 'menu';
        resetGameStats(); // Reinicia las estadísticas al volver al menú principal
        showGameInfoText(); // Muestra el texto de información al volver al menú principal
    });
    attachButtonListeners(elements.aboutButton, () => {
        customAlert('Acerca de', 'Juego de Ritmo Psico Minimalista\nDesarrollado con amor y colores pastel.\nPor RetrogisusDEV\nv0.1.0');
    });

    // Adjunta oyentes a los botones del menú de pausa
    attachButtonListeners(elements.continueButton, () => {
        gameState.phase = 'playing';
        elements.pauseMenu.classList.add('hidden');
    });
    attachButtonListeners(elements.restartButton, () => {
        elements.pauseMenu.classList.add('hidden');
        elements.scoreScreen.classList.add('hidden'); // Oculta la pantalla de puntuación si se reinicia desde allí
        elements.introAnimationText.classList.remove('hidden'); // Muestra el texto de introducción de nuevo
        elements.introAnimationText.classList.add('animate-intro'); // Inicia la animación
        gameState.phase = 'introAnimation'; // Pasa por la animación de introducción de nuevo
        gameState.introAnimationStartTime = gameState.globalTime;
    });
    attachButtonListeners(elements.exitToMenuButton, () => {
        elements.pauseMenu.classList.add('hidden');
        elements.startMenu.classList.remove('hidden');
        gameState.phase = 'menu';
        resetGameStats(); // Reinicia las estadísticas al volver al menú principal
        showGameInfoText(); // Muestra el texto de información al volver al menú principal
    });

    // Adjunta oyente al botón de cerrar alerta personalizada
    attachButtonListeners(elements.customAlertCloseButton, hideCustomAlert);

    // Adjunta oyentes a los botones de configuración del renderizador
    attachButtonListeners(elements.renderer2d, () => setRenderer('2d'));
    attachButtonListeners(elements.rendererWebGL, () => setRenderer('webgl'));

    // Adjunta oyentes a los botones de configuración de gráficos
    attachButtonListeners(elements.graphicsLow, () => setGraphicsQuality('low'));
    attachButtonListeners(elements.graphicsMedium, () => setGraphicsQuality('medium'));
    attachButtonListeners(elements.graphicsHigh, () => setGraphicsQuality('high'));

    // Adjunta oyentes a los botones de configuración de dificultad
    attachButtonListeners(elements.difficultyEasy, () => setDifficulty('easy'));
    attachButtonListeners(elements.difficultyNormal, () => setDifficulty('normal'));
    attachButtonListeners(elements.difficultyHard, () => setDifficulty('hard'));

    // Adjunta oyentes a los botones de configuración de shader
    attachButtonListeners(elements.shaderOff, () => setShaderEffect('none'));
    attachButtonListeners(elements.shaderInvert, () => setShaderEffect('invert'));
    attachButtonListeners(elements.shaderChromaticGlow, () => setShaderEffect('chromatic_glow'));

    // Adjunta oyentes a los nuevos botones de modo de color
    attachButtonListeners(elements.colorModePerRound, () => setColorMode('per_round'));
    attachButtonListeners(elements.colorModeRainbow, () => setColorMode('rainbow'));
    attachButtonListeners(elements.colorModeMonochromatic, () => setColorMode('monochromatic')); // Attach listener for new monochromatic button

    // Adjunta oyentes a los nuevos botones de anti-aliasing 2D
    attachButtonListeners(elements.imageSmoothingSmooth, () => setImageSmoothing(true));
    attachButtonListeners(elements.imageSmoothingPixelated, () => setImageSmoothing(false));

    // Attach listeners to WebGL anti-aliasing buttons
    attachButtonListeners(elements.antiAliasingNone, () => setAntiAliasing('none'));
    attachButtonListeners(elements.antiAliasingMSAAx2, () => setAntiAliasing('msaa_x2'));
    attachButtonListeners(elements.antiAliasingFXAA, () => setAntiAliasing('fxaa'));

    // Adjunta oyente al botón Jugar de Nuevo
    attachButtonListeners(elements.playAgainButton, () => {
        elements.scoreScreen.classList.add('hidden');
        elements.startMenu.classList.remove('hidden');
        gameState.phase = 'menu';
        resetGameStats();
        showGameInfoText();
    });

    // --- Inicialización ---
    window.addEventListener('resize', setCanvasSize);
    loadSettings(); // Carga la configuración de localStorage al inicio
    setupEventListeners(); // Configura los oyentes de eventos globales
    requestAnimationFrame(draw); // Inicia el bucle de animación
  </script>
</body>

</html>
